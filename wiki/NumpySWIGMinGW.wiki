#summary NumPy + SWIG + MinGW

= Content =
<wiki:toc max_depth="2" />

= Introduction =

I had a play with !NumPy, SWIG and MinGW and wanted to share my findings. The following code is C, rather than C++.

The information contained here was first made available by Bill Spotz in his article "numpy.i: a SWIG Interface File for !NumPy", and the !NumPy SVN which can be checked out using the following command:

{{{
svn co http://scipy.org/svn/numpy/trunk numpy
}}}

The !NumPy+SWIG manual is available here:
http://scipy.org/svn/numpy/trunk/doc/swig/doc/numpy_swig.pdf

You will also need the numpy.i file, which can be downloaded from the SVN:
http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i
and the pyfragments.swg file, available from
http://scipy.org/svn/numpy/trunk/doc/swig/pyfragments.swg

These two files (and others) are also available in the numpy source tarball:
http://sourceforge.net/project/showfiles.php?group_id=1369&package_id=175103

I looked at passing arrays from Python to C and recovering C arrays into Python... Basically, any _simple_ example that would help me understand how numpy.i works.

= gcc and SWIG =

Check that both gcc and SWIG are available (paths known):
{{{
swig -version
}}}

and 

{{{
gcc -v
}}}

Both should output some text...

= Modifying the pyfragments.swg file =

This is from my own tests, running SWIG Version 1.3.36 and gcc version 3.4.5 (mingw-vista special r3). I had to remove the 'static' statements from the source, otherwise your SWIGed sources won't comiple. There are only two 'static' statements in the file, both will need to be removed. Here is my modified version: pyfragments.swg

= Compilation and testing =

A setup.py file specific to each module must be written first. I based mine on the reference setup.py available in http://scipy.org/svn/numpy/trunk/doc/swig/test/ with added automatic handling of swig.

The setup command-line is (for use with MinGW):
{{{
python setup.py build --compiler=mingw32
}}}
which handles both the swig part (generation of wrapper C and Python code) and the gcc compilation part. The resulting module (a pyd file) is built in the `build\lib.win32-2.5` directory.

= A simple ARGOUT_ARRAY1 example =
This is a re-implementation of the range function. The module is called ezrange. One thing to remember with `ARGOUT_ARRAY1` is that the dimension of the array must be passed from Python.

From Bill Spotz's article: _The python user does not pass these arrays in, they simply get returned. For the case where a dimension is speciÔ¨Åed, the python user must provide that dimension as an argument._

This is useful for functions like `numpy.arange(N)`, for which the size of the array is passed to the function. For functions that follow `array_out = function(array_in)`, more work is needed (see `ARGOUTVIEW_ARRAY1` example below). 

== The C source (ezrange.c and ezrange.h) ==

Here is the ezrange.h file:
{{{
void range(int *rangevec, int n);
}}}

Here is the ezrange.c file:
{{{
void range(int *rangevec, int n)
{
    int i;

    for (i=0; i< n; i++)
        rangevec[i] = i;
}
}}}

== The interface file (ezrange.i) ==
{{{
%module ezrange

%{
    #define SWIG_FILE_WITH_INIT
    #include "ezrange.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int* ARGOUT_ARRAY1, int DIM1) {(int* rangevec, int n)}

%include "ezrange.h"
}}}

Don't forget that you will also need the [http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i numpy.i] file in the same directory.

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# ezrange extension module
_ezrange = Extension("_ezrange",
                   ["ezrange.i","ezrange.c"],
                   include_dirs = [numpy_include],
                   )

# ezrange setup
setup(  name        = "range function",
        description = "range takes an integer and returns an n element int array where each element is equal to its index",
        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_ezrange]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_ezrange.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `ezrange.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import ezrange
>>> ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _ezrange
>>> _ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

I am not sure which tests are performed in the python wrapper. Could be something important!

= A simple INPLACE_ARRAY1 example =
This example doubles the elements of the 1-D array passed to it. The operation is done in-place, which means that the array passed to the function is changed.

== The C source (inplace.c and inplace.h) ==

Here is the inplace.h file:
{{{
void inplace(double *invec, int n);
}}}

Here is the inplace.c file:
{{{
void inplace(double *invec, int n)
{
    int i;

    for (i=0; i<n; i++)
    {
        invec[i] = 2*invec[i];
    }
}
}}}

== The interface file (inplace.i) ==
{{{
%module inplace

%{
    #define SWIG_FILE_WITH_INIT
    #include "inplace.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (double* INPLACE_ARRAY1, int DIM1) {(double* invec, int n)}
%include "inplace.h"

}}}

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# inplace extension module
_inplace = Extension("_inplace",
                   ["inplace.i","inplace.c"],
                   include_dirs = [numpy_include],
                   )

# NumyTypemapTests setup
setup(  name        = "inplace function",
        description = "inplace takes a double array and doubles each of its elements in-place.",

        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_inplace]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_inplace.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `inplace.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import numpy
>>> import inplace
>>> a = numpy.array([1,2,3],'d')
>>> inplace.inplace(a)
>>> a
array([2., 4., 6.])
}}}

= A simple ARGOUTVIEW_ARRAY1 example =
This simple cumulative histogram example demonstrates the use of `ARGOUTVIEW_ARRAY1`. Given a histogram, the function returns its cumulative counterpart. Cumulative histogram element i of the cumulative histogram is the sum of all the elements of histogram elements 0 to i (see source code ezcumul.c below).

Please note, Bill Spotz advises against the use of argout_view arrays, unless absolutely necessary:

  Argoutview arrays are for when your C code provides you with a view of its internal data and does
  not require any memory to be allocated by the user. This can be dangerous. There is almost no way
  to guarantee that the internal data from the C code will remain in existence for the entire lifetime of
  the NumPy array that encapsulates it. If the user destroys the object that provides the view of the
  data before destroying the NumPy array, then using that array my result in bad memory references or
  segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply
  have no other choice.

Having said that, I don't see how to do the following without using argout_view arrays: returning an array to python when its size is not known in advance. As usual, comments welcome!

Also, I'm not sure how to handle unsuccessful memory allocations. Returning an empty array as below might not be the best option (need to generate an exception instead).

== The C source (ezcumul.c and ezcumul.h) ==

Here is the ezcumul.h file:
{{{
void cumul(int* veci, int ni, int** veco, int *n);
}}}

Here is the ezcumul.c file:
{{{
#include <stdio.h>
#include "ezcumul.h"

void cumul(int* veci, int ni, int** veco, int *n)
{
    int i;

    int *temp;

    temp = (int *)malloc(ni*sizeof(int));
    if (temp == NULL)
    {
        *n = 0;
        *veco = NULL;
        return;
    }

    temp[0] = veci[0];
    for (i=1;i<ni;i++)
    {
        temp[i]=veci[i]+temp[i-1];
    }

    *n = ni;
    *veco = temp;
}
}}}

== The interface file (ezcumul.i) ==
{{{
%module ezcumul

%{
    #define SWIG_FILE_WITH_INIT
    #include "ezcumul.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int* IN_ARRAY1, int DIM1) {(int *veci, int ni)}
%apply (int** ARGOUTVIEW_ARRAY1, int *DIM1) {(int** veco, int* n)}

%include "ezcumul.h"
}}}

Don't forget that you will also need the [http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i numpy.i] file in the same directory.

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# cumul extension module
_ezcumul = Extension("_ezcumul",
                   ["ezcumul.i","ezcumul.c"],
                   include_dirs = [numpy_include],
                   )

# NumyTypemapTests setup
setup(  name        = "cumul function",
        description = "cumul takes a histogram array and returns a cumulative histogram",
        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_ezcumul]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_ezcumul.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `ezcumul.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import ezcumul
>>> ezcumul.cumul([1,1,1])
array([1, 2, 3])
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _ezcumul
>>> _ezcumul.cumul([1,1,1])
array([1, 2, 3])
}}}

I am not sure which tests are performed in the python wrapper. Could be something important!

= Dot product example (from Bill Spotz's article) =

The last example given in Bill Spotz's artice is for a dot product function. Here is a fleshed-out version.

== The C source (dot.c and dot.h) ==

Here is the dot.h file:
{{{
double dot(int len, double* vec1, double* vec2);
}}}

Here is the dot.c file:
{{{
#include <stdio.h>
#include "dot.h"

double dot(int len, double* vec1, double* vec2)
{
    int i;
    double d;

    d = 0;
    for(i=0;i<len;i++)
        d += vec1[i]*vec2[i];

    return d;
}
}}}

== The interface files (dot.i and numpy.i) ==

Here is the complete dot.i file:
{{{
%module dot

%{
    #define SWIG_FILE_WITH_INIT
    #include "dot.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1), (int len2, double* vec2)}


%include "dot.h"
%rename (dot) my_dot;

%inline %{
    double my_dot(int len1, double* vec1, int len2, double* vec2) {
    if (len1 != len2) {
        PyErr_Format(PyExc_ValueError, "Arrays of lengths (%d,%d) given", len1, len2);
        return 0.0;
    }
    return dot(len1, vec1, vec2);
}
%}
}}}

== Setup file (setup.py) ==

This is the setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# dot extension module
_dot = Extension("_dot",
                   ["dot.i","dot.c"],
                   include_dirs = [numpy_include],
                   )

# dot setup
setup(  name        = "Dot product",
        description = "Function that performs a dot product (numpy.i: a SWIG Interface File for NumPy)",
        author      = "Egor Zindy (based on the setup.py file available in the numpy tree)",
        version     = "1.0",
        ext_modules = [_dot]
        )
}}}

== Compiling the module ==

The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing ==

Again, if everything goes according to plan, there should be a `_dot.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `dot.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import dot
>>> dot.dot([1,2,3],[1,2,3])
14.0
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _dot
>>> _dot.dot([1,2,3],[1,2,3])
14.0
}}}

= Conclusion =
That's all folks! I'll make the files available from the SVN repository ASAP. As usual, comments welcome!

Regards,
Egor