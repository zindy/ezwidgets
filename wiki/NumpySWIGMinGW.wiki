#summary NumPy + SWIG + MinGW

= Content =
<wiki:toc max_depth="2" />

= Introduction =

I had a play with !NumPy, SWIG and MinGW and wanted to share my findings. The following code is C, rather than C++.

The information contained here was first made available by Bill Spotz in his article "numpy.i: a SWIG Interface File for !NumPy", and the !NumPy SVN which can be checked out using the following command:

{{{
svn co http://scipy.org/svn/numpy/trunk numpy
}}}

The !NumPy+SWIG manual is available here:
http://scipy.org/svn/numpy/trunk/doc/swig/doc/numpy_swig.pdf

You will also need the numpy.i file, which can be downloaded from the SVN:
http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i
and the pyfragments.swg file, available from
http://scipy.org/svn/numpy/trunk/doc/swig/pyfragments.swg

These two files (and others) are also available in the numpy source tarball:
http://sourceforge.net/project/showfiles.php?group_id=1369&package_id=175103

I looked at passing arrays from Python to C and recovering C arrays into Python... Basically, any _simple_ example that would help me understand how numpy.i works.

= gcc and SWIG =

Check that both gcc and SWIG are available (paths known):
{{{
swig -version
}}}

and 

{{{
gcc -v
}}}

Both should output some text...

= Modifying the pyfragments.swg file =

This is from my own tests, running SWIG Version 1.3.36 and gcc version 3.4.5 (mingw-vista special r3). I had to remove the 'static' statements from the source, otherwise your SWIGed sources won't comiple. There are only two 'static' statements in the file, both will need to be removed. Here is my modified version: pyfragments.swg

= Compilation and testing =

A setup.py file specific to each module must be written first. I based mine on the reference setup.py available in http://scipy.org/svn/numpy/trunk/doc/swig/test/ with added automatic handling of swig.

The setup command-line is (for use with MinGW):
{{{
python setup.py build --compiler=mingw32
}}}
which handles both the swig part (generation of wrapper C and Python code) and the gcc compilation part. The resulting module (a pyd file) is built in the `build\lib.win32-2.5` directory.

= A simple ARGOUT_ARRAY1 example =
This is a re-implementation of the range function. The module is called ezrange. One thing to remember with `ARGOUT_ARRAY1` is that the dimension of the array must be passed from Python.

From Bill Spotz's article: _The python user does not pass these arrays in, they simply get returned. For the case where a dimension is speciﬁed, the python user must provide that dimension as an argument._

This is useful for functions like `numpy.arange(N)`, for which the size of the returned array is known in advance and passed to the C function.

For functions that follow `array_out = function(array_in)` where the size of array_out is _not_ known in advance and depends on memory allocated in C, see the example given in NumpyManagedMemory. 

== The C source (ezrange.c and ezrange.h) ==

Here is the ezrange.h file:
{{{
void range(int *rangevec, int n);
}}}

Here is the ezrange.c file:
{{{
void range(int *rangevec, int n)
{
    int i;

    for (i=0; i< n; i++)
        rangevec[i] = i;
}
}}}

== The interface file (ezrange.i) ==
{{{
%module ezrange

%{
    #define SWIG_FILE_WITH_INIT
    #include "ezrange.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int* ARGOUT_ARRAY1, int DIM1) {(int* rangevec, int n)}

%include "ezrange.h"
}}}

Don't forget that you will also need the [http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i numpy.i] file in the same directory.

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# ezrange extension module
_ezrange = Extension("_ezrange",
                   ["ezrange.i","ezrange.c"],
                   include_dirs = [numpy_include],
                   )

# ezrange setup
setup(  name        = "range function",
        description = "range takes an integer and returns an n element int array where each element is equal to its index",
        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_ezrange]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_ezrange.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `ezrange.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import ezrange
>>> ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _ezrange
>>> _ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

I am not sure which tests are performed in the python wrapper. Could be something important!

= A simple INPLACE_ARRAY1 example =
This example doubles the elements of the 1-D array passed to it. The operation is done in-place, which means that the array passed to the function is changed.

== The C source (inplace.c and inplace.h) ==

Here is the inplace.h file:
{{{
void inplace(double *invec, int n);
}}}

Here is the inplace.c file:
{{{
void inplace(double *invec, int n)
{
    int i;

    for (i=0; i<n; i++)
    {
        invec[i] = 2*invec[i];
    }
}
}}}

== The interface file (inplace.i) ==
{{{
%module inplace

%{
    #define SWIG_FILE_WITH_INIT
    #include "inplace.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (double* INPLACE_ARRAY1, int DIM1) {(double* invec, int n)}
%include "inplace.h"

}}}

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# inplace extension module
_inplace = Extension("_inplace",
                   ["inplace.i","inplace.c"],
                   include_dirs = [numpy_include],
                   )

# NumyTypemapTests setup
setup(  name        = "inplace function",
        description = "inplace takes a double array and doubles each of its elements in-place.",

        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_inplace]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_inplace.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `inplace.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import numpy
>>> import inplace
>>> a = numpy.array([1,2,3],'d')
>>> inplace.inplace(a)
>>> a
array([2., 4., 6.])
}}}

= A simple ARGOUTVIEW_ARRAY1 example =
== Big fat multiple warnings ==
Please note, Bill Spotz advises against the use of argout_view arrays, unless absolutely necessary:

  Argoutview arrays are for when your C code provides you with a view of its internal data and does
  not require any memory to be allocated by the user. This can be dangerous. There is almost no way
  to guarantee that the internal data from the C code will remain in existence for the entire lifetime of
  the NumPy array that encapsulates it. If the user destroys the object that provides the view of the
  data before destroying the NumPy array, then using that array my result in bad memory references or
  segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply
  have no other choice.

Python does not take care of memory de-allocation, as stated here: http://blog.enthought.com/?p=62

  The tricky part, however, is memory management. How does the memory get deallocated? The suggestions have always been something similar to “make sure the memory doesn’t get deallocated before the NumPy array disappears.” This is nice advice, but not generally helpful as it basically just tells you to create a memory leak.

Memory deallocation is also difficult to handle automatically as there is no easy way to do module "finalization". There is a Py_InitModule function, but nothing to handle deletion/destruction/finalization (this will be addressed in Python 3000 as stated in [http://www.python.org/dev/peps/pep-3121/ PEP3121]. In my example, I use the python [http://www.python.org/doc/2.5.2/lib/module-atexit.html module atexit] but there must be a better way.

Having said that, if you have no other choice, here is an example that uses ARGOUTVIEW_ARRAY1. As usual, comments welcome!

The module declares a block of memory and a couple of functions:
  * ezview.set_ones() sets all the elements (doubles) in the memory block to one and returns a numpy array that is a VIEW of the memory block.
  * ezview.get_view() simply returns a view of the memory block.
  * ezview.finalize() takes care of the memory deallocation (this is the weak part of this example).

== The C source (ezview.c and ezview.h) ==

Here is the ezview.h file:
{{{
void set_ones(double *array, int n);
}}}

Here is the ezview.c file:
{{{
#include <stdio.h>
#include <stdlib.h> 

#include "ezview.h"

void set_ones(double *array, int n)
{
    int i;

    if (array == NULL)
        return;

    for (i=0;i<n;i++)
        array[i] = 1.;
}
}}}

== The interface file (ezview.i) ==
{{{
%module ezview

%{
    #define SWIG_FILE_WITH_INIT
    #include "ezview.h"

    double *my_array = NULL;
    int my_n = 10;

    void __call_at_begining()
    {
        printf("__call_at_begining...\n");
        my_array = (double *)malloc(my_n*sizeof(double));
    }

    void __call_at_end(void)
    {
        printf("__call_at_end...\n");
        if (my_array != NULL)
            free(my_array);
    }
%}

%include "numpy.i"

%init %{
    import_array();
    __call_at_begining();
%}

%apply (double** ARGOUTVIEW_ARRAY1, int *DIM1) {(double** vec, int* n)}

%include "ezview.h"
%rename (set_ones) my_set_ones;

%inline %{
void finalize(void){
    __call_at_end();
}

void get_view(double **vec, int* n) {
    *vec = my_array;
    *n = my_n;
}

void my_set_ones(double **vec, int* n) {
    set_ones(my_array,my_n);
    *vec = my_array;
    *n = my_n;
}
%}
}}}

Don't forget that you will also need the numpy.i file in the same directory.

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# view extension module
_ezview = Extension("_ezview",
                   ["ezview.i","ezview.c"],
                   include_dirs = [numpy_include],
                   )

# NumyTypemapTests setup
setup(  name        = "ezview module",
        description = "ezview provides 3 functions: set_ones(), get_view() and finalize(). set_ones() and get_view() provide a view on a memory block allocated in C, finalize() takes care of the memory deallocation.",
        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_ezview]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

If everything goes according to plan, there should be a `_ezview.pyd` file available in the `build\lib.win32-2.5` directory. You will need to copy the file in the same directory as the SWIG generate ezview.py file.

== Testing the module ==
The test code test_ezview.py follows:
{{{
import atexit
import numpy
print "first message is from __call_at_begining()"
import ezview

#There is no easy way to finalize the module (see PEP3121)
atexit.register(ezview.finalize)

a = ezview.set_ones()
print "\ncalling ezview.set_ones() - now the memory block is all ones.\nReturned array (a view on the allocated memory block) is:"
print a

print "\nwe're setting the array using a[:]=arange(a.shape[0])\nThis changes the content of the allocated memory block:"
a[:] = numpy.arange(a.shape[0])
print a

print "\nwe're now deleting the array  - this only deletes the view,\nnot the allocated memory!"
del a

print "\nlet's get a new view on the allocated memory, should STILL contain [0,1,2,3...]"
b = ezview.get_view()
print b

print "\nnext message from __call_at_end() - finalize() registered via module atexit"
}}}
Launch test_ezview.py and the following will hopefully happen:
{{{
~> python test_ezview.py
first message is from __call_at_begining()
__call_at_begining...

calling ezview.set_ones() - now the memory block is all ones.
Returned array (a view on the allocated memory block) is:
[ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]

we're setting the array using a[:]=arange(a.shape[0])
This changes the content of the allocated memory block:
[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9.]

we're now deleting the array  - this only deletes the view,
not the allocated memory!

let's get a new view on the allocated memory, should STILL contain [0,1,2,3...]
[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9.]

next message from __call_at_end() - finalize() registered via module atexit
__call_at_end...
}}}

= Dot product example (from Bill Spotz's article) =

The last example given in Bill Spotz's artice is for a dot product function. Here is a fleshed-out version.

== The C source (dot.c and dot.h) ==

Here is the dot.h file:
{{{
double dot(int len, double* vec1, double* vec2);
}}}

Here is the dot.c file:
{{{
#include <stdio.h>
#include "dot.h"

double dot(int len, double* vec1, double* vec2)
{
    int i;
    double d;

    d = 0;
    for(i=0;i<len;i++)
        d += vec1[i]*vec2[i];

    return d;
}
}}}

== The interface files (dot.i and numpy.i) ==

Here is the complete dot.i file:
{{{
%module dot

%{
    #define SWIG_FILE_WITH_INIT
    #include "dot.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1), (int len2, double* vec2)}


%include "dot.h"
%rename (dot) my_dot;

%inline %{
    double my_dot(int len1, double* vec1, int len2, double* vec2) {
    if (len1 != len2) {
        PyErr_Format(PyExc_ValueError, "Arrays of lengths (%d,%d) given", len1, len2);
        return 0.0;
    }
    return dot(len1, vec1, vec2);
}
%}
}}}

== Setup file (setup.py) ==

This is the setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# dot extension module
_dot = Extension("_dot",
                   ["dot.i","dot.c"],
                   include_dirs = [numpy_include],
                   )

# dot setup
setup(  name        = "Dot product",
        description = "Function that performs a dot product (numpy.i: a SWIG Interface File for NumPy)",
        author      = "Egor Zindy (based on the setup.py file available in the numpy tree)",
        version     = "1.0",
        ext_modules = [_dot]
        )
}}}

== Compiling the module ==

The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing ==

Again, if everything goes according to plan, there should be a `_dot.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `dot.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import dot
>>> dot.dot([1,2,3],[1,2,3])
14.0
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _dot
>>> _dot.dot([1,2,3],[1,2,3])
14.0
}}}

= Conclusion =
That's all folks! I'll make the files available from the SVN repository ASAP. As usual, comments welcome!

Regards,
Egor