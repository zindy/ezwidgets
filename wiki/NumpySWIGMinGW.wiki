#summary NumPy + SWIG + MinGW

= Introduction =

I had a play with !NumPy, SWIG and MinGW and wanted to share my findings. The following code is C, rather than C++.

The information contained here was first made available by Bill Spotz in his article "numpy.i: a SWIG Interface File for !NumPy", and the !NumPy SVN which can be checked out using the following command:

{{{
svn co http://scipy.org/svn/numpy/trunk numpy
}}}

The !NumPy+SWIG manual is available here:
http://scipy.org/svn/numpy/trunk/doc/swig/doc/numpy_swig.pdf

You will also need the numpy.i file, which can be downloaded from the SVN:
http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i
and the pyfragments.swg file, available from
http://scipy.org/svn/numpy/trunk/doc/swig/pyfragments.swg

These two files (and others) are also available in the numpy source tarball:
http://sourceforge.net/project/showfiles.php?group_id=1369&package_id=175103

I looked at passing arrays from Python to C and recovering C arrays into Python... Basically, any _simple_ example that would help me understand how numpy.i works.

= gcc and SWIG =

Check that both gcc and SWIG are available (paths known):
{{{
swig -version
}}}

and 

{{{
gcc -v
}}}

Both should output some text...

= modifying the pyfragments.swg file =
This is from my own tests, running SWIG Version 1.3.36 and gcc version 3.4.5 (mingw-vista special r3). I had to remove the 'static' statements from the source, otherwise your SWIGed sources won't comiple. There are only two 'static' statements in the file, both will need to be removed. Here is my modified version: pyfragments.swg

= Compilation and testing =

A setup.py file specific to each module must be written first. I based mine on the reference setup.py available in http://scipy.org/svn/numpy/trunk/doc/swig/test/ with added automatic handling of swig.

The setup command-line is (for use with MinGW):
{{{
python setup.py build --compiler=mingw32
}}}
which handles both the swig part (generation of wrapper C and Python code) and the gcc compilation part. The resulting module (a pyd file) is built in the `build\lib.win32-2.5` directory.

= A simple `ARGOUT_ARRAY1` example =
This is a re-implementation of the range function. The module is called ezrange. One thing to remember with `ARGOUT_ARRAY1` is that the dimension of the array must be passed from Python.

From Bill Spotz's article: _The python user does not pass these arrays in, they simply get returned. For the case where a dimension is speciÔ¨Åed, the python user must provide that dimension as an argument._

This is useful for functions like `numpy.arange(N)`, for which the size of the array is passed to the function. For functions that follow `array_out = function(array_in)`, more work is needed (hopefully will come-up with such an example later). 

== The C source (ezrange.c and ezrange.h) ==

Here is the ezrange.h file:
{{{
void range(int *rangevec, int n);
}}}

Here is the ezrange.c file:
{{{
void range(int *rangevec, int n)
{
    int i;

    for (i=0; i< n; i++)
        rangevec[i] = i;
}
}}}

== The interface file (ezrange.i) ==
{{{
%module ezrange

%{
    #define SWIG_FILE_WITH_INIT
    #include "ezrange.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int* ARGOUT_ARRAY1, int DIM1) {(int* rangevec, int n)}

%include "ezrange.h"
}}}

Don't forget that you will also need the [http://scipy.org/svn/numpy/trunk/doc/swig/numpy.i numpy.i] file in the same directory.

== Setup file (setup.py) ==

This is my setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# ezrange extension module
_ezrange = Extension("_ezrange",
                   ["ezrange.i","ezrange.c"],
                   include_dirs = [numpy_include],
                   )

# ezrange setup
setup(  name        = "range function",
        description = "range takes an integer and returns an n element int array where each element is equal to its index",
        author      = "Egor Zindy",
        version     = "1.0",
        ext_modules = [_ezrange]
        )
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_ezrange.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `ezrange.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import ezrange
>>> ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _ezrange
>>> _ezrange.range(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
}}}

I am not sure which tests are performed in the python wrapper. Could be something important!

= A simple `INPLACE_ARRAY1` example =
This example doubles the elements of the 1-D array passed to it. The operation is done in-place, which means that the array passed to the function is changed.

== The C source (inplace.c and inplace.h) ==

Here is the inplace.h file:
{{{
void inplace(double *invec, int n);
}}}

Here is the inplace.c file:
{{{
void inplace(double *invec, int n)
{
    int i;

    for (i=0; i<n; i++)
    {
        invec[i] = 2*invec[i];
    }
}
}}}

== The interface file (inplace.i) ==
{{{
%module inplace

%{
    #define SWIG_FILE_WITH_INIT
    #include "inplace.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (double* INPLACE_ARRAY1, int DIM1) {(double* invec, int n)}
%include "inplace.h"

}}}

== Setup file (setup.py) ==

This is my setup.py file:
{{{
}}}

== Compiling the module ==
The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing the module ==
If everything goes according to plan, there should be a `_inplace.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `inplace.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import numpy
>>> import inplace
>>> a = numpy.array([1,2,3],'d')
>>> inplace.inplace(a)
>>> print a
array([2, 4, 6])
}}}

= Dot product example (from Bill Spotz's article) =

The last example given in Bill Spotz's artice is for a dot product function. Here is a fleshed-out version.

== The C source (dot.c and dot.h) ==

Here is the dot.h file:
{{{
double dot(int len, double* vec1, double* vec2);
}}}

Here is the dot.c file:
{{{
#include <stdio.h>
#include "dot.h"

double dot(int len, double* vec1, double* vec2)
{
    int i;
    double d;

    d = 0;
    for(i=0;i<len;i++)
        d += vec1[i]*vec2[i];

    return d;
}
}}}

== The interface files (dot.i and numpy.i) ==

Here is the complete dot.i file:
{{{
%module dot

%{
    #define SWIG_FILE_WITH_INIT
    #include "dot.h"
%}

%include "numpy.i"

%init %{
    import_array();
%}

%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1), (int len2, double* vec2)}

%include "dot.h"
%rename (dot) my_dot;

%inline %{
    double my_dot(int len1, double* vec1, int len2, double* vec2) {
    if (len1 != len2) {
        PyErr_Format(PyExc_ValueError, "Arrays of lengths (%d,%d) given", len1, len2);
        return 0.0;
    }
    return dot(len1, vec1, vec2);
}
%}
}}}

== Setup file (setup.py) ==

This is the setup.py file:
{{{
#! /usr/bin/env python

# System imports
from distutils.core import *
from distutils      import sysconfig

# Third-party modules - we depend on numpy for everything
import numpy

# Obtain the numpy include directory.  This logic works across numpy versions.
try:
    numpy_include = numpy.get_include()
except AttributeError:
    numpy_include = numpy.get_numpy_include()

# dot extension module
_dot = Extension("_dot",
                   ["dot.i","dot.c"],
                   include_dirs = [numpy_include],
                   )

# dot setup
setup(  name        = "Dot product",
        description = "Function that performs a dot product (numpy.i: a SWIG Interface File for NumPy)",
        author      = "Egor Zindy (based on the setup.py file available in the numpy tree)",
        version     = "1.0",
        ext_modules = [_dot]
        )
}}}

== Compiling the module ==

The setup command-line is:
{{{
python setup.py build --compiler=mingw32
}}}

== Testing ==

Again, if everything goes according to plan, there should be a `_dot.pyd` file available in the `build\lib.win32-2.5` directory. Two options: You can copy the file in the directory with the `dot.py` file (generated by swig), in which case, the following will work (in python):
{{{
>>> import dot
>>> dot.dot([1,2,3],[1,2,3])
14.0
}}}

The other option is to go in the `build\lib.win32-2.5` directory and test the python library directly (from python, notice the underscore):
{{{
>>> import _dot
>>> _dot.dot([1,2,3],[1,2,3])
14.0
}}}

= Conclusion =
That's all folks! I'll make the files available from the SVN repository ASAP. As usual, comments welcome!

Regards,
Egor